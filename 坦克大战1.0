import pygame
from time import sleep
import random
from pygame.sprite import collide_rect
#设置通用属性
BG_COLOR = pygame.Color(0,0,0)
SCREEN_WIDTH = 700
SCREEN_HEIGHT = 600
TEXT_COLOR = pygame.Color(255,0,0)

class Tank():
    '''
    坦克类
    '''
    def __init__(self):
        self.live = True
        #定义记录坦克原来的位置
        self.old_left = 0
        self.old_top = 0
    #坦克的移动方法
    def move(self)->None:
        #记录坦克原来的位置,为了方便还原碰撞后的位置
        self.old_left = self.rect.left
        self.old_top = self.rect.top
        # 如果stop为True（不移动），直接返回，不执行后续移动逻辑
        if self.stop:
            return
        if self.direction == 'L':
            #判断是否超出左边边界
            if self.rect.left>0:
                #修改坦克的位置：离左边的位置-操作
                self.rect.left = self.rect.left - self.speed
        elif self.direction == 'R':
            #判断是否超出右边边界
            if self.rect.left + self.rect.width<SCREEN_WIDTH:
                #修改坦克的位置：离左边的位置+操作
                self.rect.left = self.rect.left + self.speed  
        elif self.direction == 'U':
            #判断是否超出上边边界
            if self.rect.top > 0:
                #修改坦克的位置：离上面的位置-操作
                self.rect.top = self.rect.top - self.speed  
        elif self.direction == 'D':
            #判断是否超出上边边界
            if self.rect.top + self.rect.height < SCREEN_HEIGHT:
                #修改坦克的位置：离上面的位置-操作
                self.rect.top = self.rect.top + self.speed
    #碰撞墙壁的方法
    def hitWalls(self):
        '''
        碰撞墙壁
        '''
        for wall in MainGame.wall_list:
            # 判断是否碰撞
            if collide_rect(self,wall):
                # 修改子弹的状态
                self.live = False
    #射击方法
    def shot(self):
        pass
    #展示坦克
    def displayTank(self):
        '''
        展示坦克
        '''
        #获取最新的坦克朝向的图片
        self.image = self.images.get(self.direction)
        MainGame.Window.blit(self.image,self.rect)
    def tank_hit_wall(self)->None:
        '''
        坦克与墙壁的碰撞
        '''
        for wall in MainGame.wall_list:
            #检测坦克是否与墙壁发生了碰撞
            if pygame.sprite.collide_rect(self,wall):
                '''这里判断碰撞墙壁之后想让坦克不穿墙，那么不穿墙其实就是想让
                坦克不继续移动了，那意思其实就让坦克的坐标保持不变，修改坐标的话，
                那问题是修改哪一个坐标，这时候我们就要进行相应的坐标记录，因为我们是while true不断
                刷新的游戏，它可以设置成不断记录每一帧的坐标'''
            #将位置还原到碰撞前的位置
                self.rect.left = self.old_left
                self.rect.top = self.old_top
            #写在写好坦克的位置还原之后问题是怎么调用它，应该在坦克每次移动的时候去调用它，在MainGame里面
    def tank_collide_tank(self,tank)->None:#注意这里要传一个tank参数，不然下面tank.live就无法调用，因为我们是在Tank大类下，还没生成这个类，因此不能直接写tank：Tank
        '''
        判断两个坦克是否发生碰撞
        '''
        #判断是否都存活
        if tank is not None and self.live and tank.live:
            if pygame.sprite.collide_rect(self,tank):
                self.rect.left = self.old_left
                self.rect.top = self.old_top

class MyTank(Tank):
    def __init__(self,left:int,top:int)->None:
        super(MyTank,self).__init__()
        #设置我方坦克的图片资源
        self.images = {
            'L':pygame.image.load('.\\img\\p1tankL.gif'),
            'R':pygame.image.load('.\\img\\p1tankR.gif'),
            'U':pygame.image.load('.\\img\\p1tankU.gif'),
            'D':pygame.image.load('.\\img\\p1tankD.gif'),
        }
        #设置我方坦克的方向
        self.direction = 'L'
        #加载图片方向和坦克方向一致
        self.image = self.images.get(self.direction)
        #让图片生成矩形图片格式
        self.rect = self.image.get_rect() #因为它直接利用了self.image,所以要放这行
        #设置我方坦克位置
        self.rect.left = left #把left参数赋值给self.rect.left属性
        self.rect.top = top #把top参数赋值给self.rect.top属性
        #设置移动速度
        self.speed = 3
        #设置移动开关
        self.stop = True #True表示不移动，False表示移动
    #碰撞敌方坦克的方法
    def hitEnemyTank(self):
        pass
class EnemyTank(Tank):
    '''
    敌方坦克类
    '''
    def __init__(self,left,top,speed) -> None:
        super(EnemyTank,self).__init__() #继承父类坦克类的live等属性
        self.images = {
            'L':pygame.image.load('.\\img\\enemy1L.gif'),
            'R':pygame.image.load('.\\img\\enemy1R.gif'),
            'U':pygame.image.load('.\\img\\enemy1U.gif'),
            'D':pygame.image.load('.\\img\\enemy1D.gif'),
        }
        #设置敌方坦克的方向
        self.direction = self.rand_direction()
        #获取图片信息
        self.image = self.images.get(self.direction)
        #获取图像的形状
        self.rect = self.image.get_rect()
        #设置敌方坦克位置
        self.rect.left = left
        self.rect.top = top
        #设置敌方坦克的速度
        self.speed = speed
        #设置移动开关
        self.stop = False #True表示不移动，False表示移动,这样修改之后的意思是默认移动
        #设置移动的步长
        self.step = 30
    def rand_direction(self)->str:
        ''''
        生成随机方向
        '''
        choice = random.randint(1,4)
        if choice == 1:
            return'U'
        if choice == 2:
            return'D'
        if choice == 3:
            return'L'
        if choice == 4:
            return'R'
    def rand_move(self):
        '''
        随机移动
        '''
        #判断步长是否小于0
        if self.step <= 0:
            #如果小于0，重新更换方向
            self.direction = self.rand_direction()
            #重置步长
            self.step = 30
        else:
            #如果大于0，移动
            self.move()
            #步长减1
            self.step -= 1
    def shot(self):
        '''
        敌方坦克的射击
        '''
        num = random.randint(1,100)
        if num < 5: #这样相当于百分之三十的概率发射子弹
            return Bullet(self) #注意这个self属性是敌方坦克的本身，因此这样可以区分子弹属于谁
class Bullet:
    '''
    子弹类
    '''
    def __init__(self,tank) -> None:
        #加载子弹图片
        self.image = pygame.image.load('.\\img\\enemymissile.gif')
        #获取子弹方向
        self.direction = tank.direction
        #获取子弹的图形
        self.rect = self.image.get_rect()

        if self.direction == 'L':
            #子弹的位置 = 坦克的位置 - 子弹的宽度
                self.rect.left = tank.rect.left - self.rect.width
                self.rect.top = tank.rect.top + 1/2*tank.rect.height - self.rect.height/2
        elif self.direction == 'R':
            #子弹的位置 = 坦克的位置 - 子弹的宽度
                self.rect.left = tank.rect.left + tank.rect.width
                self.rect.top = tank.rect.top + 1/2*tank.rect.height - self.rect.height/2
        elif self.direction == 'U':
            #子弹的位置 = 坦克的位置 - 子弹的宽度
                self.rect.left = tank.rect.left + tank.rect.width/2 - self.rect.width/2
                self.rect.top = tank.rect.top - self.rect.height
        elif self.direction == 'D':
            #子弹的位置 = 坦克的位置 - 子弹的宽度
                self.rect.left = tank.rect.left + tank.rect.width/2 - self.rect.width/2
                self.rect.top = tank.rect.top + tank.rect.height
        #设置子弹的速度
        self.speed = 3
        #设置子弹的状态
        self.live = True
    def display_bullet(self) -> None:
        '''
        显示子弹
        '''
        MainGame.Window.blit(self.image,self.rect)
    def move(self) -> None:
        '''
        子弹的移动
        '''
        #根据子弹的生成方向来的移动
        if self.direction == 'L':
            #判断子弹是否超出屏幕
            if self.rect.left > 0:
                self.rect.left -= self.speed
            else:
                self.live = False
        elif self.direction == 'R':
            if self.rect.left < SCREEN_WIDTH - self.rect.width:
                self.rect.left += self.speed
            else:
                self.live = False
        elif self.direction == 'U':
            if self.rect.top > 0:
                self.rect.top -= self.speed
            else:
                self.live = False 
        elif self.direction == 'D':
            if self.rect.top < SCREEN_HEIGHT -self.rect.height:
                self.rect.top += self.speed
            else:
                self.live = False
    def hit_enemy_tank(self):
        for e_tank in MainGame.enemy_tank_list:  #这样就不用坦克信息的传递了，可以直接拿到坦克的信息
            # 判断子弹是否击中坦克
            if collide_rect(self,e_tank):
                # 爆炸效果
                explode = Explode(e_tank)
                MainGame.explode_list.append(explode)#要把爆炸的效果一一的放在列表里才好去渲染
                # 修改子弹的状态
                self.live = False
                e_tank.live = False
    def hit_my_tank(self):
        #判断我方坦克是否活着
        if MainGame.my_tank and MainGame.my_tank.live:
            # 判断子弹是否击中坦克
            if collide_rect(self,MainGame.my_tank):
                # 爆炸效果
                explode = Explode(MainGame.my_tank)
                MainGame.explode_list.append(explode)#要把爆炸的效果一一的放在列表里才好去渲染
                # 修改子弹的状态
                self.live = False
                MainGame.my_tank.live = False
    def hit_wall(self)->None:
        '''
        碰撞墙壁
        '''
        for wall in MainGame.wall_list:
            # 判断是否碰撞
            if collide_rect(self,wall):
                # 修改子弹的状态
                self.live = False
                #修改墙壁的生命值
                wall.hp -= 1
                #判断墙壁是否应该显示
                if wall.hp <= 0:
                    wall.live = False
                # 创建音乐对象
                music = Music('.\\img\\hit.wav')
                #创建完还要调用播放音乐
                Music.play_music(music)
class Explode:
    '''
    爆炸效果类
    '''
    def __init__(self,tank:Tank) -> None: #因为爆炸的时候是坦克的位置爆炸，所以要把坦克的属性传递过来
        # 加载爆炸效果的图片
        self.images = [
            pygame.image.load('.\\img\\blast0.gif'),
            pygame.image.load('.\\img\\blast1.gif'),
            pygame.image.load('.\\img\\blast2.gif'),
            pygame.image.load('.\\img\\blast3.gif'),
            pygame.image.load('.\\img\\blast4.gif')
        ]
        #设置爆炸效果的位置
        self.rect = tank.rect
        #设置爆炸效果的索引
        self.step = 0
        #获取需要渲染的图像
        self.image = self.images[self.step]
        #设置爆炸的状态
        self.live = True
    def display_explode(self) -> None:
        '''
        显示爆炸效果
        '''
        # 判断当前爆炸效果的图像是否播放完毕
        if self.step < len(self.images):
            #获取当前爆炸效果的图像
            self.image = self.images[self.step]
            #获取下一张爆炸效果的索引
            self.step += 1
            #绘制爆炸效果
            MainGame.Window.blit(self.image,self.rect)
        else:
            #初始化爆炸的一个索引
            self.step = 0
            #设置爆炸效果的状态，代表爆炸过了
            self.live = False
class Wall:
    '''
    墙壁类
    '''
    def __init__(self,left,top)->None:
        #加载图片
        self.image = pygame.image.load('.\\img\\steels.gif')
        #获取图片的图形
        self.rect = self.image.get_rect()
        #设置墙壁的位置
        self.rect.left = left
        self.rect.top = top
        #设置墙壁的生命值
        self.hp = 3
        #设置墙壁的状态
        self.live = True
    def display_wall(self)->None:
        '''
        显示墙壁
        '''
        MainGame.Window.blit(self.image,self.rect)
class Music:
    '''
    音效类
    '''
    pygame.mixer.init()
    def __init__(self,filename:str): #filename的意思是去告诉我们文件的地址
        # 创建音乐文件
        pygame.mixer.music.load(filename)
    def play_music(self)->None:
        '''
        播放音效
        '''
        pygame.mixer.music.play()
class MainGame:
    '''
    游戏主窗口类
    '''
    #游戏主窗口对象
    Window = None
    #设置我方坦克
    my_tank = None
    #设置敌方坦克的列表
    enemy_tank_list = []
    #设置敌方坦克的数量
    enemy_tank_count = 6
    #存储我方子弹的列表
    my_bullet_list = []
    #存储地方坦克的列表
    enemy_bullet_list = []
    #存储爆炸效果的列表
    explode_list = []
    #存储墙壁的列表
    wall_list = []
    def __init__(self) ->None:
        pass 
    def get_text_surface(self,text:str) -> pygame.Surface:
        '''
        获取文字的图片
        '''
        #初始化文字对象
        pygame.font.init()
        #获取可获取的字体
        #print(pygame.font.get_fonts())
        #创建字体
        font = pygame.font.SysFont('kaiti',18)
        #绘制文本信息
        text_surface = font.render(text,True,TEXT_COLOR)
        #将绘制的文字信息返回
        return text_surface
    def get_event(self) ->None:
        '''
        获取事件
        '''
        #获取所有事件
        event_list = pygame.event.get()
        #遍历事件
        for event in event_list:
            #判断是什么事件，然后做出相应的处理
            if event.type == pygame.QUIT:
                #点击关闭按钮
                self.end_game()
            #判断事件类型是否为按键按下，如果是，继续判断按键是哪一个按键，来进行对应的处理
            if event.type == pygame.KEYDOWN:
                if not MainGame.my_tank and event.key == pygame.K_TAB:
                        #按TAB重生我方坦克
                        print('重生我方坦克')
                        self.create_my_tank()
                #判断我方坦克是否活着
                if MainGame.my_tank and MainGame.my_tank.live:
                #按下键盘
                    if event.key == pygame.K_LEFT:
                        print('坦克向左移动')
                        #修改方向
                        MainGame.my_tank.direction = 'L'
                        MainGame.my_tank.stop = False  # 关键：按下时允许移动
                    elif event.key == pygame.K_RIGHT:
                        print('坦克向右移动')
                        #修改方向
                        MainGame.my_tank.direction = 'R'
                        MainGame.my_tank.stop = False  # 关键：按下时允许移动
                    elif event.key == pygame.K_UP:
                        print('坦克向上移动')
                        #修改方向
                        MainGame.my_tank.direction = 'U'
                        MainGame.my_tank.stop = False  # 关键：按下时允许移动
                    elif event.key == pygame.K_DOWN:
                        print('坦克向下移动')
                        #修改方向
                        MainGame.my_tank.direction = 'D'
                        MainGame.my_tank.stop = False  # 关键：按下时允许移动
                    elif event.key == pygame.K_SPACE:
                        #判断子弹是否上限
                        if len(MainGame.my_bullet_list) < 5:
                            #渲染子弹
                            print('发射子弹')
                            #创建子弹
                            m_bullet = Bullet(MainGame.my_tank)
                            #将子弹添加到列表中
                            MainGame.my_bullet_list.append(m_bullet)
                            # 创建音乐对象
                            music = Music('.\\img\\fire.wav')
                            #创建完还要调用播放音乐
                            Music.play_music(music)
            if event.type == pygame.KEYUP:
                #松开的如果是方向键，才更改移动开关状态
                if event.key == pygame.K_LEFT or event.key == pygame.K_RIGHT or\
                    event.key == pygame.K_UP or event.key == pygame.K_DOWN:
                    #判断我方坦克是否活着
                    if MainGame.my_tank and MainGame.my_tank.live:
                        MainGame.my_tank.stop = True
    def start_game(self) ->None:
        '''
        开始游戏
        '''
        #初始化游戏窗口
        pygame.display.init() 
        #创建一个窗口
        MainGame.Window = pygame.display.set_mode((SCREEN_WIDTH,SCREEN_HEIGHT))
        #设置窗口标题
        pygame.display.set_caption('坦克大战1.0')
        #创建一个我方坦克
        self.create_my_tank()
        #创建敌方坦克
        self.create_enemy_tank()
        #创建墙壁
        self.create_wall()
        #刷新窗口
        while True:

            sleep(0.02)
            # 1.填充背景（清空画布）
            MainGame.Window.fill(BG_COLOR)
            # 2.生成并绘制文字
            # num = 6
            text = self.get_text_surface(f'敌方坦克数量剩余{len(MainGame.enemy_tank_list)}')
            MainGame.Window.blit(text,(10,10))
            #增加事件
            self.get_event()
            #判断我方坦克是否存活
            if MainGame.my_tank and MainGame.my_tank.live:
                #显示我方坦克
                MainGame.my_tank.displayTank()
            else:
                MainGame.my_tank = None
            #显示敌方坦克
            self.display_enemy_tank()
            #判断我方坦克是否存活
            if MainGame.my_tank and MainGame.my_tank.live:
                #执行我方坦克移动（会先判断stop状态）
                MainGame.my_tank.move()
                #检测我方坦克是否与墙壁发生碰撞
                MainGame.my_tank.tank_hit_wall()
                #检测我方坦克是否与敌方坦克发生碰撞
                for enemy in MainGame.enemy_tank_list:
                    MainGame.my_tank.tank_collide_tank(enemy)
            #显示我方子弹
            self.display_my_bullet()
            #显示敌方子弹
            self.display_enemy_bullet()
            #显示爆炸效果
            self.display_explode()
            #显示墙壁
            self.display_wall()
            # 3.刷新窗口（让绘制的内容显示出来）
            pygame.display.update()
    def create_my_tank(self)->None:
        '''
        创造我方坦克
        '''
        MainGame.my_tank = MyTank(350,450)
        # 创建音乐对象
        music = Music('.\\img\\start.wav')
        #创建完还要调用播放音乐
        Music.play_music(music)
    def create_enemy_tank(self)->None:
        ''''
        创建敌方坦克
        '''
        self.enemy_top = 100
        self.enemy_speed =2
        for i in range(self.enemy_tank_count):
            #生成坦克的位置
            left = random.randint(0,600)
            #创建敌方坦克
            e_tank = EnemyTank(left,self.enemy_top,self.enemy_speed)
            #将敌方坦克加到列表中
            self.enemy_tank_list.append(e_tank)
    def create_wall(self)->None:
        '''
        创建墙壁
        '''
        top = 200
        for i in range(6):
            #创建墙壁
            wall = Wall(i*128,top)
            #将墙壁类添加到列表中
            MainGame.wall_list.append(wall)
    def display_wall(self)->None:
        '''
        显示墙壁
        '''
        for wall in MainGame.wall_list:
            if wall.live:
                #显示墙壁
                wall.display_wall()
            else:
                MainGame.wall_list.remove(wall)
    def display_explode(self)->None:
        for explode in MainGame.explode_list:
            #判断是否活着
            if explode.live:
                #显示爆炸效果
                explode.display_explode()
            else:
                MainGame.explode_list.remove(explode)
    def display_my_bullet(self)->None:
        for my_bullet in MainGame.my_bullet_list:
            #显示我方子弹
            if my_bullet.live:
                my_bullet.display_bullet()
                my_bullet.move()
                #判断我方子弹是否击中敌方坦克
                my_bullet.hit_enemy_tank()
                #判断子弹是否击中墙壁
                my_bullet.hit_wall()
            else:
                #从列表中移除，这样不光是超出边界不显示，还能大大减少内存问题
                MainGame.my_bullet_list.remove(my_bullet)
    def display_enemy_bullet(self)->None: #这仅仅是定义方法，还要去调用它
        ''''
        显示敌方子弹
        '''
        for e_bullet in MainGame.enemy_bullet_list:
            #判断敌方子弹是否存活 
            if e_bullet.live:
                #显示敌方子弹
                e_bullet.display_bullet()
                #移动敌方子弹
                e_bullet.move()
                #判断是否击中我方坦克
                e_bullet.hit_my_tank()
                #判断子弹是否击中墙壁
                e_bullet.hit_wall()
            else:
                MainGame.enemy_bullet_list.remove(e_bullet)       
    def display_enemy_tank(self)->None:
        '''
        显示敌方坦克
        '''
        for e_tank in self.enemy_tank_list:
            #判断敌方坦克是否存活
            if e_tank.live:
                #显示敌方坦克
                e_tank.displayTank()
                #移动敌方坦克
                e_tank.rand_move()
                #判断敌方坦克是否与墙壁发生碰撞
                e_tank.tank_hit_wall()
                #判断敌方坦克是否与我方坦克发生碰撞
                e_tank.tank_collide_tank(MainGame.my_tank)#因为我方坦克在进行移动时候有多个敌方坦克，所以这里二者的代码有所不同,注意调用tank_collide_tank方法，需要传入tank参数
                #让敌方坦克发射子弹
                e_bullet = e_tank.shot() #这样之后还不会发射，因为这样仅仅是创建出来了一个具体的对象
                #判断是否有子弹
                if e_bullet:
                    #将子弹添加到列表中
                    MainGame.enemy_bullet_list.append(e_bullet)
            else:
                #从列表中删除
                self.enemy_tank_list.remove(e_tank)
    def end_game(self) ->None: 
        '''
        结束游戏
        '''
        print('结束使用,欢迎再次使用')
        exit()
if __name__ == '__main__':
    #调用Maingame里面的start_game方法
    MainGame().start_game()